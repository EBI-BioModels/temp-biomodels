
#
# This file is automatically generated with 
# the System Biology Format Converter (http://sbfc.sourceforge.net/)
# from an SBML file.
#

#
# Model name = Nikolaev2019 - Immunobiochemical reconstruction of influenza lung infection-melanoma skin cancer interactions
#
# isDescribedBy http://identifiers.org/pubmed/30745900
# is http://identifiers.org/biomodels.db/MODEL1911180001
# is http://identifiers.org/biomodels.db/BIOMD0000000865
#

# some function definitions that are allowed in SBML but not valid in xpp
ceil(x)=flr(1+x)

@delay=50


# FunctionDefinition id = Function_for_Bcl6_Production, name = Function_for_Bcl6_Production
Function_(a_c,U,n_c,A_c,M_c,r_c,B,I,C)=(a_c*U^n_c/(A_c^n_c+U^n_c)*M_c^r_c/(M_c^r_c+B^r_c+I^r_c+C^r_c))


# FunctionDefinition id = Function_for_IRF4_Production, name = Function_for_IRF4_Production
Functio_1(Phi_L_P,sigma_i,a_i,U,n_i,A_i,k_i,B,m_i,K_i,I,s_i,Q_i,q_i)=(Phi_L_P*(sigma_i+a_i*U^n_i/(A_i^n_i+U^n_i)+k_i*B^m_i/(K_i^m_i+B^m_i)+q_i*I^s_i/(Q_i^s_i+I^s_i)))


# FunctionDefinition id = Function_for_PD1_Production, name = Function_for_PD1_Production
Functio_2(sigma_p,a_p,U,n_p,A_p,M_p,r_p,B)=((sigma_p+a_p*U^n_p/(A_p^n_p+U^n_p))*M_p^r_p/(M_p^r_p+B^r_p))


# FunctionDefinition id = Function_for_Blimp1_Production, name = Function_for_Blimp1_Production
Functio_3(a_b,U,n_b,A_b,k_b,I,m_b,K_b,r_b,M_b,C)=((a_b*U^n_b/(A_b^n_b+U^n_b)+k_b*I^m_b/(K_b^m_b+I^m_b))*M_b^r_b/(M_b^r_b+C^r_b))


# Compartment: id = compartment, name = compartment, constant
par compartme=1.0

# Parameter:   id =  sigma_i, name = sigma_i, constant
par sigma_i=0.3

# Parameter:   id =  sigma_p, name = sigma_p, constant
par sigma_p=0.1

# Parameter:   id =  a_c, name = a_c, constant
par a_c=0.75

# Parameter:   id =  a_p, name = a_p, constant
par a_p=0.75

# Parameter:   id =  a_i, name = a_i, constant
par a_i=75.0

# Parameter:   id =  a_b, name = a_b, constant
par a_b=100.0

# Parameter:   id =  A_c, name = A_c, constant
par A_c_1=0.01

# Parameter:   id =  A_p, name = A_p, constant
par A_p_1=0.1

# Parameter:   id =  A_i, name = A_i, constant
par A_i_1=1.0

# Parameter:   id =  A_b, name = A_b, constant
par A_b_1=10.0

# Parameter:   id =  n_c, name = n_c, constant
par n_c=3.0

# Parameter:   id =  n_p, name = n_p, constant
par n_p=3.0

# Parameter:   id =  n_b, name = n_b, constant
par n_b=2.0

# Parameter:   id =  n_i, name = n_i, constant
par n_i=2.0

# Parameter:   id =  k_b, name = k_b, constant
par k_b=25.0

# Parameter:   id =  k_i, name = k_i, constant
par k_i=7.5

# Parameter:   id =  q_i, name = q_i, constant
par q_i=7.5

# Parameter:   id =  K_b, name = K_b, constant
par K_b_1=1.0

# Parameter:   id =  K_i, name = K_i, constant
par K_i_1=1.0

# Parameter:   id =  Q_i, name = Q_i, constant
par Q_i_1=1.0

# Parameter:   id =  m_b, name = m_b, constant
par m_b=2.0

# Parameter:   id =  m_i, name = m_i, constant
par m_i=2.0

# Parameter:   id =  s_i, name = s_i, constant
par s_i=2.0

# Parameter:   id =  M_b, name = M_b, constant
par M_b_1=10.0

# Parameter:   id =  M_c, name = M_c, constant
par M_c=10.0

# Parameter:   id =  M_p, name = M_p, constant
par M_p=10.0

# Parameter:   id =  H_p, name = H_p, constant
par H_p=0.1

# Parameter:   id =  H_L, name = H_L, constant
par H_L=0.1

# Parameter:   id =  r_b, name = r_b, constant
par r_b=2.0

# Parameter:   id =  r_c, name = r_c, constant
par r_c=2.0

# Parameter:   id =  r_p, name = r_p, constant
par r_p=4.0

# Parameter:   id =  h_L, name = h_L, constant
par h_L_1=4.0

# Parameter:   id =  mu_c, name = mu_c, constant
par mu_c=0.1

# Parameter:   id =  mu_p, name = mu_p, constant
par mu_p=0.1

# Parameter:   id =  mu_b, name = mu_b, constant
par mu_b=1.0

# Parameter:   id =  mu_i, name = mu_i, constant
par mu_i=1.0

# Parameter:   id =  L, name = L, constant
par L=0.0

# Parameter:   id =  K_i_nu, name = K_i_nu, constant
par K_i_nu=0.001

# Parameter:   id =  K_p, name = K_p, constant
par K_p=0.01

# Parameter:   id =  gamma_y, name = gamma_y, constant
par gamma_y=500.0

# Parameter:   id =  gamma_p, name = gamma_p, constant
par gamma_p=500.0

# Parameter:   id =  delta, name = delta, constant
par delta=5000.0

# Parameter:   id =  theta, name = theta, constant
par theta=50000.0

# Parameter:   id =  lambda, name = lambda, constant
par lambda=10000.0

# Parameter:   id =  alpha, name = alpha, constant
par alpha=1.0E-4

# Parameter:   id =  kappa, name = kappa, constant
par kappa=1.0

# Parameter:   id =  y_a_k, name = y_a_k, defined by a Rule

# Parameter:   id =  c_T_a_k, name = c_T_a_k, defined by a Rule

# Parameter:   id =  nu_k, name = nu_k, defined by a Rule

# Parameter:   id =  mu_a_k, name = mu_a_k, defined by a Rule

# Parameter:   id =  phi_L_P, name = phi_L_P, defined by a Rule

# Parameter:   id =  U_a_k_P, name = U_a_k_P, defined by a Rule

# Parameter:   id =  sigma_p_tilde, name = sigma_p_tilde, defined by a Rule

# Parameter:   id =  k_T, name = k_T, constant
par k_T=0.5

# Parameter:   id =  K_T, name = K_T, constant
par K_T_1=1.0

# Parameter:   id =  n_T, name = n_T, constant
par n_T=2.0

# Parameter:   id =  T, name = T, constant
par T_renamed=0.0

# Parameter:   id =  Phi_L_P, name = Phi_L_P, defined by a Rule

# assignmentRule: variable = sigma_p_tilde
sigma_p_t=sigma_p+k_T*T_renamed^n_T/(K_T_1^n_T+T_renamed^n_T)
aux sigma_p_t=sigma_p_t

# assignmentRule: variable = phi_L_P
phi_L_P=H_p/(H_p+L*P)
aux phi_L_P=phi_L_P

# assignmentRule: variable = c_T_a_k
c_T_a_k=0.5*(1+alpha+kappa-((1+alpha+kappa)^2-4*alpha)^0.5)
aux c_T_a_k=c_T_a_k

# assignmentRule: variable = nu_k
nu_k=K_p/(kappa+K_i_nu)*kappa/(kappa+K_p)
aux nu_k=nu_k

# assignmentRule: variable = y_a_k
y_a_k=(1+lambda*nu_k*c_T_a_k)/(1+gamma_y+lambda*nu_k*c_T_a_k)
aux y_a_k=y_a_k

# assignmentRule: variable = mu_a_k
mu_a_k=(1+delta*y_a_k)/(1+gamma_p+theta*nu_k*c_T_a_k+delta*y_a_k)
aux mu_a_k=mu_a_k

# assignmentRule: variable = U_a_k_P
U_a_k_P=mu_a_k*phi_L_P
aux U_a_k_P=U_a_k_P

# assignmentRule: variable = Phi_L_P
Phi_L_P_1=H_L^h_L_1/(H_L^h_L_1+(L*P)^h_L_1)
aux Phi_L_P_1=Phi_L_P_1

# Reaction: id = Bcl6_Production, name = Bcl6_Production

Bcl6_Prod=compartme*Function_(a_c, U_a_k_P, n_c, A_c_1, M_c, r_c, B, I, C)

# Reaction: id = Bcl6_Degradation, name = Bcl6_Degradation

Bcl6_Degr=compartme*mu_c*C

# Reaction: id = PD1_Production, name = PD1_Production

PD1_Produ=compartme*Functio_2(sigma_p_t, a_p, U_a_k_P, n_p, A_p_1, M_p, r_p, B)

# Reaction: id = PD1_Degradation, name = PD1_Degradation

PD1_Degra=compartme*mu_p*P

# Reaction: id = IRF4_Production, name = IRF4_Production

IRF4_Prod=compartme*Functio_1(Phi_L_P_1, sigma_i, a_i, U_a_k_P, n_i, A_i_1, k_i, B, m_i, K_i_1, I, s_i, Q_i_1, q_i)

# Reaction: id = IRF4_Degradation, name = IRF4_Degradation

IRF4_Degr=compartme*mu_i*I

# Reaction: id = Blimp1_Degradation, name = Blimp1_Degradation

Blimp1_De=compartme*mu_b*B

# Reaction: id = Blimp1_Production, name = Blimp1_Production

Blimp1_Pr=compartme*Functio_3(a_b, U_a_k_P, n_b, A_b_1, k_b, I, m_b, K_b_1, r_b, M_b_1, C)

# Species:   id = C, name = C, affected by kineticLaw

init C=1.0
dC/dt=(1/(compartme))*(( 1.0 * Bcl6_Prod) + (-1.0 * Bcl6_Degr))

# Species:   id = P, name = P, affected by kineticLaw

init P=1.0
dP/dt=(1/(compartme))*(( 1.0 * PD1_Produ) + (-1.0 * PD1_Degra))

# Species:   id = I, name = I, affected by kineticLaw

init I=1.0
dI/dt=(1/(compartme))*(( 1.0 * IRF4_Prod) + (-1.0 * IRF4_Degr))

# Species:   id = B, name = B, affected by kineticLaw

init B=1.0
dB/dt=(1/(compartme))*((-1.0 * Blimp1_De) + ( 1.0 * Blimp1_Pr))

@ meth=cvode, tol=1e-6, atol=1e-8
# @ maxstor=1e6
@ bound=40000, total=200
done

