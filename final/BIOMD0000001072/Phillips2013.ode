
#
# This file is automatically generated with 
# the System Biology Format Converter (http://sbfc.sourceforge.net/)
# from an SBML file.
#

#
# Model name = Phillips2013 - physiologically based modeling explaining Mammalian rest/activity patterns
#
# is http://identifiers.org/biomodels.db/MODEL2003080001
# is http://identifiers.org/biomodels.db/BIOMD0000001072
#

# some function definitions that are allowed in SBML but not valid in xpp
ceil(x)=flr(1+x)

@delay=50


# FunctionDefinition id = Fy_syn, name = Fy_prod
Fy_syn(B,Y,kappa)=(B*Y/3/kappa)


# FunctionDefinition id = FV_v_reg, name = FV_v_reg
FV_v_reg(B,D_null,H,Q_max,V_m,X,a,b,delta,eta,k,sigma_comma,tau_v,theta,v_vb,v_vd,v_vh,v_vm)=((v_vm*Q_max/(1+exp((theta-V_m)/sigma_comma))+v_vd*(a*k*(X+delta)+b)+v_vh*eta*H+v_vb*eta*B+D_null)/tau_v)


# FunctionDefinition id = Rate_Law_for_H_degradation, name = Rate Law for H degradation
Rate_Law_(H,chi)=(1/chi*H)


# FunctionDefinition id = Fx_reg_y, name = Fx_reg_y
Fx_reg_y(Y,kappa)=(Y/kappa)


# FunctionDefinition id = Rate_Law_for_V_m_degradation, name = Rate Law for V_m degradation
Rate_La_1(V_m,tau_m)=(1/tau_m*V_m)


# FunctionDefinition id = Fn_deg, name = Fn_deg
Fn_deg(alpha,beta,n)=(60*(alpha+beta)*n)


# FunctionDefinition id = FH_reg_V_m, name = FH_reg_V_m
FH_reg_V_(Q_max,V_m,chi,mu,sigma_comma,theta)=(mu*Q_max/(1+exp((theta-V_m)/sigma_comma))/chi)


# FunctionDefinition id = Fn_syn, name = Fn_prod
Fn_syn(alpha)=(60*alpha)


# FunctionDefinition id = FV_m_reg, name = FV_m_reg
FV_m_reg(A_null,Q_max,V_v,X,a,b,delta,k,sigma_comma,tau_m,theta,v_md,v_mv)=((v_mv*Q_max/(1+exp((theta-V_v)/sigma_comma))+v_md*(a*k*(X+delta)+b)+A_null)/tau_m)


# FunctionDefinition id = Fx_prod, name = Fx_prod
Fx_prod(B,Theta,X,gamma,kappa,q,rho)=((gamma*(X/3+4/3*X^3-256/105*X^7)+B+rho*(1/3-Theta)*(1-tanh(q*X)))/kappa)


# FunctionDefinition id = Fy_reg_x, name = Fy_reg_x
Fy_reg_x(B,X,day,f,h,kappa,tau_c)=((-X)*((day/(f*tau_c))^2+h*B)/kappa)


# FunctionDefinition id = Rate_Law_for_V_v_degradation, name = Rate Law for V_v degradation
Rate_La_2(V_v,tau_v)=(1/tau_v*V_v)


# Compartment: id = individual, name = Default, constant
par individua=1.0

# Parameter:   id =  Theta, name = Theta
par Theta=0.0

# Parameter:   id =  Q_max, name = Q_max, constant
par Q_max=100.0

# Parameter:   id =  theta, name = theta, constant
par theta_1=10.0

# Parameter:   id =  sigma_comma, name = sigma_comma, constant
par sigma_com=3.0

# Parameter:   id =  G, name = G, constant
par G=37.0

# Parameter:   id =  r, name = r, constant
par r=0.4

# Parameter:   id =  h, name = h, constant
par h=0.55

# Parameter:   id =  q, name = q, constant
par q=10.0

# Parameter:   id =  rho, name = rho, constant
par rho=0.032

# Parameter:   id =  kappa, name = kappa, constant
par kappa=13750.9870831398

# Parameter:   id =  f, name = f, constant
par f=0.99729

# Parameter:   id =  tau_c, name = tau_c, constant
par tau_c=24.2

# Parameter:   id =  gamma, name = gamma, constant
par gamma=0.13

# Parameter:   id =  delta, name = delta, constant
par delta=-0.7

# Parameter:   id =  a, name = a, constant
par a=1.0

# Parameter:   id =  k, name = k, constant
par k=17.0

# Parameter:   id =  b, name = b, constant
par b=4.8

# Parameter:   id =  v_vd, name = v_vd, constant
par v_vd=-0.17

# Parameter:   id =  v_md, name = v_md, constant
par v_md=-0.08

# Parameter:   id =  v_vb, name = v_vb, constant
par v_vb=0.0

# Parameter:   id =  eta, name = eta, constant
par eta=1.0

# Parameter:   id =  A_null, name = A_null, constant
par A_null=1.3

# Parameter:   id =  D_null, name = D_null, constant
par D_null=-4.8

# Parameter:   id =  chi, name = chi, constant
par chi=79200.0

# Parameter:   id =  mu, name = mu, constant
par mu=4.4

# Parameter:   id =  v_vh, name = v_vh, constant
par v_vh=1.0

# Parameter:   id =  v_vm, name = v_vm, constant
par v_vm=-2.1

# Parameter:   id =  v_mv, name = v_mv, constant
par v_mv=-1.8

# Parameter:   id =  tau_v, name = tau_v, constant
par tau_v=10.0

# Parameter:   id =  tau_m, name = tau_m, constant
par tau_m=10.0

# Parameter:   id =  B, name = B, defined by a Rule

# Parameter:   id =  alpha, name = alpha, defined by a Rule

# Parameter:   id =  beta, name = beta, constant
par beta=1.11111111111111E-4

# Parameter:   id =  day, name = day, constant
par day=24.0

# Parameter:   id =  Qm, name = Qm, defined by a Rule

# Parameter:   id =  B_circumflex, name = B_circumflex, defined by a Rule

# Parameter:   id =  Omega, name = Omega
par Omega=0.0

# Parameter:   id =  I_on, name = I_on, constant
par I_on=0.0

# Parameter:   id =  I_tilded, name = I_tilded, defined by a Rule

# Parameter:   id =  I, name = I
par I=0.0

# Parameter:   id =  alpha_null, name = alpha_null, constant
par alpha_nul=0.00166666666666667

# Parameter:   id =  I_null, name = I_null, constant
par I_null=9500.0

# Parameter:   id =  p, name = p, constant
par p=0.5

# Parameter:   id =  I_one, name = I_one, constant
par I_one=10.0

# Parameter:   id =  ModelValue_4, name = Initial for G, constant
par ModelValu=37.0

# Parameter:   id =  ModelValue_41, name = Initial for I_null, constant
par ModelVa_1=9500.0

# Parameter:   id =  ModelValue_37, name = Initial for I_on, constant
par ModelVa_2=0.0

# Parameter:   id =  ModelValue_1, name = Initial for Q_max, constant
par ModelVa_3=100.0

# Parameter:   id =  ModelValue_40, name = Initial for alpha_null, constant
par ModelVa_4=0.00166666666666667

# Parameter:   id =  ModelValue_42, name = Initial for p, constant
par ModelVa_5=0.5

# Parameter:   id =  ModelValue_5, name = Initial for r, constant
par ModelVa_6=0.4

# Parameter:   id =  ModelValue_3, name = Initial for sigma_comma, constant
par ModelVa_7=3.0

# Parameter:   id =  ModelValue_2, name = Initial for theta, constant
par ModelVa_8=10.0

# assignmentRule: variable = Qm
Qm=ModelVa_3/(1+exp((ModelVa_8-V_m)/ModelVa_7))
aux Qm=Qm

# assignmentRule: variable = I_tilded
# the operator ModelValue_37 is not supported by xpp
# the formula is : Omega*ModelValue_37* piecew1 
#Rule ignored : there are some unsupported functions !!

# assignmentRule: variable = alpha
alpha=ModelVa_4*(I_tilded/ModelVa_1)^ModelVa_5*I_tilded/(I_tilded+I_one)
aux alpha=alpha

# assignmentRule: variable = B_circumflex
B_circumf=ModelValu*alpha*(1-n)
aux B_circumf=B_circumf

# assignmentRule: variable = B
B_1=(1-ModelVa_6*X)*(1-ModelVa_6*Y)*B_circumf
aux B_1=B_1

# Reaction: id = Vm_deg, name = V_m_Degradation

Vm_deg=individua*Rate_La_1(V_m, tau_m)

# Reaction: id = Vv_deg, name = V_v_Degradation

Vv_deg=individua*Rate_La_2(V_v, tau_v)

# Reaction: id = Vm_Vv, name = V_v_Regulation

Vm_Vv=individua*FV_v_reg(B_1, D_null, H_1, Q_max, V_m, X, a, b, delta, eta, k, sigma_com, tau_v, theta_1, v_vb, v_vd, v_vh, v_vm)

# Reaction: id = Vv_Vm, name = V_m_Regulation

Vv_Vm=individua*FV_m_reg(A_null, Q_max, V_v, X, a, b, delta, k, sigma_com, tau_m, theta_1, v_md, v_mv)

# Reaction: id = Vm_H, name = H_Regulation_by_V_m

Vm_H=individua*FH_reg_V_(Q_max, V_m, chi, mu, sigma_com, theta_1)

# Reaction: id = H_deg, name = H_Degradation

H_deg=individua*Rate_Law_(H_1, chi)

# Reaction: id = X_syn, name = x_Production

X_syn=individua*Fx_prod(B_1, Theta, X, gamma, kappa, q, rho)

# Reaction: id = Y_syn, name = y_Production

Y_syn=individua*Fy_syn(B_1, Y, kappa)

# Reaction: id = n_deg, name = n_Degradation

n_deg=individua*Fn_deg(alpha, beta, n)

# Reaction: id = n_syn, name = n_Production

n_syn=individua*Fn_syn(alpha)

# Reaction: id = Y_X, name = x_Regulation_by_y

Y_X=individua*Fx_reg_y(Y, kappa)

# Reaction: id = X_Y, name = y_Regulation_by_x

X_Y=individua*Fy_reg_x(B_1, X, day, f, h, kappa, tau_c)

# Species:   id = V_v, name = V_v(mean_cell_body_potential_VLPO), affected by kineticLaw

init V_v=3.82007920893978
dV_v/dt=(1/(individua))*((-1.0 * Vv_deg) + ( 1.0 * Vm_Vv))

# Species:   id = V_m, name = V_m(mean_cell_body_potential_MA), affected by kineticLaw

init V_m=-17.5981186613022
dV_m/dt=(1/(individua))*((-1.0 * Vm_deg) + ( 1.0 * Vv_Vm))

# Species:   id = H, name = H(sleep_homeostatic_drive), affected by kineticLaw

par H_1=5.57377096632541
aux H_1=H_1
dH_1/dt=(1/(individua))*(( 1.0 * Vm_H) + (-1.0 * H_deg))

# Species:   id = n, name = n(fraction_of_photoreceptors_that_are_activated), affected by kineticLaw

init n=0.0
dn/dt=(1/(individua))*((-1.0 * n_deg) + ( 1.0 * n_syn))

# Species:   id = X, name = x(SCN_activity), affected by kineticLaw

init X=-0.644229940134898
dX/dt=(1/(individua))*(( 1.0 * X_syn) + ( 1.0 * Y_X))

# Species:   id = Y, name = y(complement_of_x), affected by kineticLaw

init Y=-0.803527836803535
dY/dt=(1/(individua))*(( 1.0 * Y_syn) + ( 1.0 * X_Y))

# event : asleep
# unable to handle events with delays currently.
# event ignored.


# event : awake
# unable to handle events with delays currently.
# event ignored.


# event : day_0
# unable to handle events with delays currently.
# event ignored.


# event : night
# unable to handle events with delays currently.
# event ignored.



# Piecewise functions : the mathML piecewise element is transformed into if/then/else expression

piecew1=if ((I  <  0) xor ((24*3600)  <  0)) then (I-24*3600*ceil(I/(24*3600))) else (I-24*3600*flr(I/(24*3600)))


@ meth=cvode, tol=1e-6, atol=1e-8
# @ maxstor=1e6
@ bound=40000, total=200
done

